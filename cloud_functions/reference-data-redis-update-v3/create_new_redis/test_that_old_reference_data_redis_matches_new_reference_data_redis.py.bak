'''
Author: Developer Ray
Date: 2024-08-30
Last Editor: Developer Ray
Last Edit Date: 2024-09-26
Description: First, check that the keys are identical between the two redis instances. Then, for each key, 
             check that the snapshot in the old reference data redis matches the most recent snapshot from the new 
             reference data redis. NOTE: heavily written by ChatGPT.
             Use `python -u test_that_old_reference_data_redis_matches_new_reference_data_redis.py >> output.txt` to print output into a file.
             Use `nohup python -u test_that_old_reference_data_redis_matches_new_reference_data_redis.py >> output.txt 2>&1 &` to run the above procedure in the background (can close the connection to the VM).
'''
import pickle

import numpy as np
import pandas as pd

from transfer_old_reference_data_to_new_redis import REFERENCE_DATA_FEATURES, OLD_REFERENCE_DATA_REDIS_CLIENT, REFERENCE_DATA_REDIS_CLIENT


TERMINATE_ON_FIRST_MISMATCH = False


def is_nan(value):
    '''Utility function to check if a value is `np.nan` or equivalent.'''
    return pd.isna(value) or (isinstance(value, float) and np.isnan(value))


def compare_arrays_deprecated(arr1: np.array, arr2: np.array) -> np.array:
    nan_mask = np.isnan(arr1) & np.isnan(arr2)    # check where both arrays are `np.nan`
    equality_mask = (arr1 == arr2)    # compare the arrays, excluding `np.nan` values
    return np.where(nan_mask, True, equality_mask)    # `np.where(condition, x, y)` where `condition` is a boolean array that is evaluated element-wise, `x` is a value to pick when the `condition` is `True`, `y` is a value to pick when `condition` is `False`


def compare_arrays(arr1: np.array, arr2: np.array) -> np.array:
    '''Compare `arr1` and `arr2` element-wise and treat `np.nan` values as equal.
    
    >>> array1 = np.array([1.0, 2.0, np.nan, 4.0, np.nan])
    >>> array2 = np.array([1.0, 2.0, np.nan, 4.0, np.nan])
    >>> compare_arrays(array1, array2)
    array([ True,  True,  True,  True,  True])
    '''
    assert len(arr1) == len(arr2), 'Numpy arrays must be of the same length for comparison'

    def compare_values(v1, v2) -> bool:
        # handle `np.nan`s: If both are `np.nan`, treat them as equal
        v1_is_nan, v2_is_nan = is_nan(v1), is_nan(v2)
        if is_nan(v1) and is_nan(v2):
            return True
        elif (v1_is_nan and not v2_is_nan) or (not v1_is_nan and v2_is_nan):
            return False
        # For other values, use normal equality check
        elif v1 == v2:
            return True
        else:
            return False
    
    return np.array([compare_values(v1, v2) for v1, v2 in zip(arr1, arr2)])


if __name__ == '__main__':
    # Fetch all keys from both instances
    old_keys = set(OLD_REFERENCE_DATA_REDIS_CLIENT.keys())
    new_keys = set(REFERENCE_DATA_REDIS_CLIENT.keys())

    # Step 1: Check if keys are identical between the two Redis instances
    if old_keys != new_keys:
        print('The keys in both Redis instances are not identical.')
        diff_old = old_keys - new_keys
        diff_new = new_keys - old_keys
        if diff_old:
            print(f'Keys in old Redis but not in new Redis: {diff_old}')
        if diff_new:
            print(f'Keys in new Redis but not in old Redis: {diff_new}')
    else:
        print(f'The {len(old_keys)} keys in both Redis instances are identical.')

    # Step 2: For each key, compare the unpickled values
    mismatched_keys = []
    keys_inspected = []
    print(f'Inspecting the values between the two redis instances for {len(old_keys)} keys')
    for idx, key in enumerate(old_keys):
        old_value = OLD_REFERENCE_DATA_REDIS_CLIENT.get(key)
        new_value = REFERENCE_DATA_REDIS_CLIENT.get(key)

        if old_value is not None and new_value is not None:
            # Unpickle the values
            old_unpickled_value = pickle.loads(old_value)
            new_unpickled_value = pickle.loads(new_value)
            
            # Compare the old value with the first item of the new value
            old_unpickled_value = old_unpickled_value[REFERENCE_DATA_FEATURES].to_numpy()
            new_unpickled_value = new_unpickled_value[0]
            if not all(compare_arrays(old_unpickled_value, new_unpickled_value)):
                mismatched_keys.append(key)
                if TERMINATE_ON_FIRST_MISMATCH:
                    print(f'The following key has a mismatched value: {key}')
                    print(f'Value in old redis:\n{old_unpickled_value}')
                    print(f'Value in new redis:\n{new_unpickled_value}')
                    break
        else:
            print(f'One of the Redis instances does not have the key: {key}')
        keys_inspected.append(key)
        if idx % 1000 == 999:
            print(f'Inspected {idx + 1} keys so far: {keys_inspected}')
            keys_inspected = []

    # Step 3: Report any mismatched keys
    if mismatched_keys:
        print(f'{len(mismatched_keys)} keys with mismatched values: {mismatched_keys}')
    else:
        print(f'All {len(old_keys)} keys have matching values.')
