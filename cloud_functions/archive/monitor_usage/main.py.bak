'''
Author: Developer Ray
Date: 2023-07-06
Last Editor: Developer Ray
Last Edit Date: 2023-12-28
'''
import time
from functools import wraps
from datetime import timedelta

import smtplib
from email.mime.text import MIMEText

from auxiliary_functions import get_bq_client, sqltodf


EMAIL_RECIPIENTS = ['eng@ficc.ai']    # , 'gil@ficc.ai', 'eng@ficc.ai', 'myles@ficc.ai']
YEAR_MONTH_DAY_HOUR_MIN_SEC = '%Y-%m-%d' + ' ' + '%H:%M:%S'


# # Uncomment the below lines for testing
# import os
# os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = '/Users/user/ficc/ficc/mitas_creds.json'


def function_timer(function_to_time):
    '''This function is to be used as a decorator. It will print out the execution time of `function_to_time`.'''
    @wraps(function_to_time)    # used to ensure that the function name is still the same after applying the decorator when running tests: https://stackoverflow.com/questions/6312167/python-unittest-cant-call-decorated-test
    def wrapper(*args, **kwargs):    # using the same formatting from https://docs.python.org/3/library/functools.html
        print(f'BEGIN {function_to_time.__name__}')
        start_time = time.time()
        result = function_to_time(*args, **kwargs)
        end_time = time.time()
        print(f'END {function_to_time.__name__}. Execution time: {timedelta(seconds=end_time - start_time)}')
        return result
    return wrapper


def get_email_message_split_by_hostname(df):
    '''Group `df` by hostname so we can see if there is correlation between a particular 
    company and their usage.'''
    message = ''
    df['hostname'] = df['user'].apply(lambda user: user.split('@')[1])
    for hostname, hostname_df in df.groupby('hostname'):
        hostname_df = hostname_df.drop(columns=['hostname'])
        hostname_df['user'] = df['user'].apply(lambda user: user.split('@')[0])
        message += f'---------- @{hostname} ----------\n\n'
        message += hostname_df.to_string(index=False, col_space=25, justify='right')
        message += '\n\n'
    return message + '\n'


def get_email_message_split_by_hostname_and_user(df):
    '''Group `df` by hostname and then further isolate by user so we can see if there 
    is correlation between a particular company and their usage.'''
    message = ''
    users = df['user'].unique()
    hostname_to_usernames = {}
    for user in users:
        username, hostname = user.split('@')
        if hostname not in hostname_to_usernames: hostname_to_usernames[hostname] = []
        hostname_to_usernames[hostname].append(username)
    for hostname, usernames in hostname_to_usernames.items():
        message += f'---------- @{hostname} ----------\n\n'
        for username in usernames:
            user = username + '@' + hostname
            df_user = df[df['user'] == user]
            message += f'{username}\n'
            df_user = df_user.drop(columns='user')
            message += df_user.to_string(index=False, col_space=25, justify='right')
            message += '\n\n'
        message += '\n'
    return message


@function_timer
def get_user_errors_email_message():
    '''Gets all CUSIPs that did not price that were attempted to be priced by users today.'''
    query = '''SELECT user, time, cusip, calc_date, batch
               FROM
                 `eng-reactor-287421.api_calls_tracker.usage_data`
               WHERE error
                 AND DATE(time) = current_date('EST')
                 AND INSTR(user, 'ficc.ai') = 0'''
    user_errors_df = sqltodf(query, get_bq_client())
    message = '--------------------Errors encountered by users today--------------------\n'
    if len(user_errors_df) == 0: return message + 'No errors encountered by users today!\n\n\n'

    user_errors_df = user_errors_df.rename(columns={'calc_date': 'error_message'})
    user_errors_df['time'] = user_errors_df['time'].dt.strftime(YEAR_MONTH_DAY_HOUR_MIN_SEC)
    return message + get_email_message_split_by_hostname_and_user(user_errors_df)


@function_timer
def get_uses_email_message():
    '''Gets all CUSIPs that were priced by users today. Second return value is a boolean indicating 
    whether there was any usage today.'''
    query = '''SELECT user, count(user) as total_searches, max(time) as latest_login
               FROM
                 `eng-reactor-287421.api_calls_tracker.usage_data`
               WHERE DATE(time) = current_date('EST')
                 AND INSTR(user, 'ficc.ai') = 0
               GROUP BY user 
               ORDER BY total_searches'''
    uses_df = sqltodf(query, get_bq_client())
    message = '--------------------Usage today--------------------\n'
    if len(uses_df) == 0: return message + 'No usage today.\n\n\n', False
    uses_df['latest_login'] = uses_df['latest_login'].dt.strftime(YEAR_MONTH_DAY_HOUR_MIN_SEC)
    return message + get_email_message_split_by_hostname(uses_df), True


@function_timer
def get_top_differences_email_message():
    '''For user priced trades, we want to see if there was a recent (within the last 7 days) trade with the 
    same CUSIP that had a similar (within 20%) quantity and same trade direction. If this trade exists, then 
    we look at the price difference between our predicted price and the actual price at which the trade occurs. 
    We isolate the top 10 price differences.'''
    query = '''SELECT user, time, cusip, direction, quantity * 1000 AS quantity, ficc_price, ficc_ytw, rtrs_control_number, trade_date, time_of_trade, par_traded, dollar_price, yield, coupon, price_diff
               FROM (
                   SELECT *, ROW_NUMBER() OVER(PARTITION BY cusip, direction, quantity ORDER BY trade_date, time_of_trade DESC) AS rnum
                   FROM (
                       SELECT logs.user, logs.time, logs.cusip, logs.direction, logs.quantity, logs.ficc_price, logs.ficc_ytw, msrb.par_traded, msrb.yield, msrb.dollar_price, msrb.rtrs_control_number, msrb.trade_date, msrb.time_of_trade,logs.ficc_price - msrb.dollar_price AS price_diff, logs.ficc_ycl, logs.calc_date, msrb.coupon
                       FROM `eng-reactor-287421.api_calls_tracker.usage_data` AS logs LEFT JOIN `MSRB.msrb_trade_messages` AS msrb ON msrb.cusip = logs.cusip AND msrb.trade_type = logs.direction
                       WHERE INSTR(logs.user, 'ficc.ai') = 0    -- exclude @ficc.ai users
                           AND DATE(logs.time) = CURRENT_DATE('EST')
                           AND msrb.par_traded <= logs.quantity * 1000 * 1.2    -- upper bound for msrb.par_traded is 20 percent more than the quantity inputted by user
                           AND msrb.par_traded >= logs.quantity * 1000 * 0.8    -- lower bound for msrb.par_traded is 20 percent less than the quantity inputted by user
                           AND logs.error IS FALSE    -- no need to compare when there is an error since the yield and price value are NUMERICAL_ERROR
                           AND DATE_DIFF(CURRENT_DATE('EST'), trade_date, day) < 7) )    -- trade_date can be at most 7 days before today
               WHERE rnum = 1    -- keep only the most recent trade of the day that matches CUSIP and direction
               ORDER BY ABS(price_diff) DESC    -- sort by largest absolute differences since magnitude, not direction, is important here
               LIMIT 10    -- only output the top 10 to not get distracted by smaller errors'''
    top_differences_df = sqltodf(query, get_bq_client())
    message = '--------------------Top 10 price differences based on usage today--------------------\n'
    if len(top_differences_df) == 0: return message + 'No trades in the last week that are similar to usage today.\n\n\n'
    
    top_differences_df['time'] = top_differences_df['time'].dt.strftime(YEAR_MONTH_DAY_HOUR_MIN_SEC)
    top_differences_df['par_traded'] = top_differences_df['par_traded'].astype(int)
    top_differences_df['ficc_price'] = top_differences_df['ficc_price'].astype(float)    # removes trailing 0's
    top_differences_df['ficc_ytw'] = top_differences_df['ficc_ytw'].astype(float)    # removes trailing 0's
    # top_differences_df['coupon'] = top_differences_df['ficc_ytw'].astype('string').str.strip(''.join(['.' + '0'*i for i in range(1, 10)] + ['0'*i for i in range(1, 10)]))    # removes all trailing 0's from coupon values
    top_differences_df['trade_datetime'] = top_differences_df['trade_date'].astype('string') + ' ' + top_differences_df['time_of_trade'].astype('string')
    top_differences_df = top_differences_df.drop(columns=['trade_date', 'time_of_trade'])
    return message + get_email_message_split_by_hostname(top_differences_df)


def send_email(subject, message='', recipients=EMAIL_RECIPIENTS):
    '''This function comes directly from `cloud_functions/check_demo_status/main.py`.'''
    sender_email = 'notifications@ficc.ai'
    password = 'ztwbwrzdqsucetbg'
    smtp_server = 'smtp.gmail.com'
    port = 587
    
    server = smtplib.SMTP(smtp_server, port)
    server.starttls()
    server.login(sender_email, password)
    
    message = MIMEText(message)
    message['Subject'] = subject
    message['From'] = sender_email
    message['To'] = ', '.join(recipients)
    
    try:
        server.sendmail(sender_email, recipients, message.as_string())
    except Exception as e:
        print(e)
    server.quit()


def main(args):
    email_message, there_was_usage_today = get_uses_email_message()
    if not there_was_usage_today:
        send_email('No usage today')
    else:
        email_message += get_user_errors_email_message()
        email_message += get_top_differences_email_message()
        send_email('Usage summary', email_message)
    return f'Email sent to {EMAIL_RECIPIENTS}'
